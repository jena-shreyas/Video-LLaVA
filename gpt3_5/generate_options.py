import os
import os.path as osp
import sys
import re
import json
import openai
from typing import List, Dict, Tuple
from tqdm import tqdm
from data.convert_data_format import create_prompts

abspath = osp.abspath(__file__)
dname = osp.dirname(osp.dirname(abspath))
os.chdir(dname)

DATA_DIR = "data/causalvidqa"
ANNOT_DIR = "annotations"
OUTPUT_DIR = osp.join(DATA_DIR, ANNOT_DIR, "annotated")

with open(osp.join(DATA_DIR, "video2captions.json"), 'r') as f:
    vid2cap = json.load(f)

openai.api_type = "azure"
openai.api_base = "https://gpt35newdec23.openai.azure.com/"
openai.api_version = "2023-09-15-preview"
openai.api_key = "45a56bedd7d54f30ab4a622cdce4803d"

instr = '''
      TASK:

        With the video summary as input, a question with multiple choice options and the correct option is provided. 
        Using the video summary, create four wrong options for the question using the given correct option (ignore the original wrong options). 
        Also, for each generated option, provide the method by which the wrong option was generated from the question and answer.

      GUIDELINES:

      - The options should be statements, NOT questions.
      - The options should NOT answer the question correctly.
      - The options should be coherent and grammatically correct.
      - Options generated by adding a possible consequence of some event or action mentioned in the question create CORRECT OPTIONS, NOT WRONG OPTIONS! Instead, you must use an opposite of the consequence or an unrelated event.
      - The options should be created using the living things (e.g., woman, swimmer, horse), objects (e.g., hammer, bowl), places (e.g., meadow, house) and associated events (e.g., playing, eating) mentioned in the video summary as much as possible.
      - Option generation should be done keeping in mind that the video description might be noisy and there might be undetected or misclassified objects in it.
      - The options should be diverse and not repetitive in meaning.

      e.g., 

        Video Summary:
          The photographer waited until the sun was setting to capture the perfect picture. 
          [person_1] and [person_2] were all smiles as they posed for the perfect wedding picture by the beach in the backdrop of the sunset.
          Meanwhile, [person_3] and [person_4], though not in the picture, were standing nearby, giggling and talking among themselves.

        (1) 
          QUESTION: 
            Why are [person_1] and [person_2] smiling?

          QUESTION TYPE:
            Explanatory

          ANSWER:
            Because [person_1] and [person_2] are posing for their wedding photo.

          GENERATED WRONG OPTIONS:

            a. <OPT> Because [person_1] got injured. </OPT> <MET> Since [person_1] and [person_2] are smiling, it must be a happy occasion. Since the opposite of happy is sad/painful, generate a wrong option describing a sad/painful experience, i.e. injury. </MET>    
            b. <OPT> Because [person_1] and [person_2] are enjoying playing football. </OPT> <MET> Since [person_1] and [person_2] are smiling, it must be a happy occasion. So, generate a wrong option by replacing the wedding with another happy activity, i.e. enjoying playing football. </MET>
            c. <OPT> Because [person_3] and [person_4] are posing for their wedding photo. </OPT> <MET> [person_1] and [person_2] are getting married. So, generate a wrong option by replacing the people getting married with [person_3] and [person_4], who are mentioned in the video summary but not getting married. </MET>
            d. <OPT> Because [person_1] and [person_2] are enjoying the sunrise. </OPT> <MET> The video summary mentions that there is a sunset at the time of the wedding. So, generate a wrong option by keeping the wedding as the same but changing the time of day, i.e., sunrise. </MET>

        (2)

          QUESTION: 
            What would happen if [person_3] and [person_4] photobombed?

          QUESTION TYPE:
            Counterfactual

          ANSWER:
            [person_1] and [person_2] would not have the perfect wedding photo at sunset by the beach.

          GENERATED WRONG OPTIONS:

            a. <OPT> [person_1] and [person_2] would not have the perfect wedding photo at sunrise by the beach. </OPT> <MET> The video summary mentions that there is a sunset at the time of the wedding. So, generate a wrong option by keeping the wedding as the same but changing the time of day, i.e., sunrise. </MET>
            b. <OPT> [person_1] and [person_2] would be thrilled. </OPT> <MET> If someone is photobombing your wedding picture, you might be irritated or angry. So, generate a wrong option by adding the opposite emotion, i.e., thrilled. </MET>
            c. <OPT> [person_1] and [person_2] would not have the perfect wedding photo at sunset by the lake. </OPT> <MET> The video summary mentions that the location is a sea beach. So, generate a wrong option by replacing with another location, i.e. lake. </MET>
            d. <OPT> [person_1] and [person_2] would be anxious. </OPT> <MET> If someone is photobombing your wedding picture, you might be irritated or angry. So, generate a wrong option by adding an unrelated emotion, i.e., anxious. </MET>

      '''

qn_ans = '''
              QUESTION: 
                {}

              QUESTION TYPE:
                {}
              
              ANSWER:
                {}

              GENERATED WRONG OPTIONS:
         '''
                
def parse_outputs(output: str,
                  num_options: int) -> List[Tuple]:
    pattern = r'[a-d]. <OPT>(.*?)</OPT> <MET>(.*?)</MET>'
    try:
      opt_met : List[Tuple[str, str]] = re.findall(pattern, output)        # list of (option, method) tuples
      for opt, met in opt_met:
        if len(opt) == 0 or len(met) == 0:    # check validity of options and methods
          raise Exception("Empty option or method!")
      assert len(opt_met) == num_options - 1, f"Expected {num_options - 1} options, got {len(opt_met)} options"
      opt_met = [(opt.strip(), met.strip()) for opt, met in opt_met]
      return opt_met
    except Exception as e:
      print(e)
      print(opt_met)
      print("Error in parsing the output")
      return None


def generate_options(data: List[Dict],
                     output_filename: str) -> None:

    global instr, qn_ans, OUTPUT_DIR, vid2cap
    generated_data = []
    for i, d in enumerate(tqdm(data, total=len(data))):
      video_file = d['video'].split('.')[0]
      video_desc = vid2cap[video_file]
      question = d['question']
      answer = d[f"a{int(d['answer'])}"]
      qn_type = d["qn_type"]
      qn_answers = qn_ans.format(question, qn_type, answer)
      num_options = d['num_option']
      prompt = f'''{instr}
    
              VIDEO SUMMARY: 
              
               {video_desc}
              
              {qn_answers}
            '''
    
      chat_completion = openai.Completion.create(
        engine="gpt35tdec23",
        prompt=prompt,
        temperature=1,
        max_tokens=330,
        top_p=0.5,
        frequency_penalty=0,
        presence_penalty=0,
        stop=None)

      output = chat_completion["choices"][0]["text"]
      parsed_options = parse_outputs(output, num_options)
      if parsed_options is not None:
        ans_idx = int(d['answer'])
        k = 0
        d["methods"] = {}
        for i in range(num_options):
          if i == ans_idx:
            continue
          option, method = parsed_options[k]
          d[f"a{i}"] = option
          d["methods"][f"a{i}"] = method
          k += 1

        human_prompt, gpt_prompt = create_prompts(d)
        d['conversations'] = [
              {'from': 'human', 'value': human_prompt},
              {'from': 'gpt', 'value': gpt_prompt}
        ]

        generated_data.append(d)

      if i % 2 == 0:
        with open(osp.join(OUTPUT_DIR, output_filename), 'w') as f:
          json.dump(generated_data, f)

    with open(osp.join(OUTPUT_DIR, output_filename), 'w') as f:
      json.dump(generated_data, f)


if __name__ == "__main__":
  filename = sys.argv[1]      # original/data_original.json_
  dirname = osp.dirname(filename)
  output_filename = osp.join(dirname, osp.basename(filename).split('.')[0] + "_gpt3_5.json")
  with open(osp.join(DATA_DIR, ANNOT_DIR, filename), 'r') as f:
    data : List = json.load(f)

  generate_options(data, output_filename)






#   text = "   a. <OPT> [person_1] would be very happy. </OPT> <MET> The video summary does not provide any information that would suggest that cutting into someone would make them happy. So, generate a wrong option by adding an opposite emotion, i.e., happy. </MET> \
#              b. <OPT> [person_1] would be very angry. </OPT> <MET> The video summary does not provide any information that would suggest that cutting into someone would make them angry. So, generate a wrong option by adding an unrelated emotion, i.e., angry. </MET> \
#              c. <OPT> [person_1] would have to swim to the shore. </OPT>\
#              d. <OPT> [person_1] would have to get off the boat and find a new one. </OPT> <MET> The video summary mentions that the scene is set on a boat. So, generate a wrong option by adding an unrelated event, i.e., finding a new boat. </MET> \
#           "

#  # <MET> The video summary mentions that the scene is set on a boat. So, generate a wrong option by adding an unrelated event, i.e., swimming to the shore. </MET> 
  
# # d. <OPT> [person_1] would have to get off the boat and find a new one. </OPT> <MET> The video summary mentions that the scene is set on a boat. So, generate a wrong option by adding an unrelated event, i.e., finding a new boat. </MET> \
  
#   options = parse_outputs(text, 5)
#   if options is not None:
#     for option, method in options:
#       print("Option :", option, " | Method :", method)
  
